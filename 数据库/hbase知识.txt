hbase是一个稀疏的、分布式的、持久化的、多维的映射，由行健、列键和时间戳索引。
HBase权威指南的实例代码下载地址：https://github.com/larsgeorge/hbase-book
1.hbase的列族 需要在创建表时就创建好，不能修改得太频繁，数量也不能太多，列族数量只限于几十
  列族名必须由可打印字符组成
2.hbase的列 是没有限制的 一个列族可以有数百万个列，列值没有类型和长度的限制
  每一列的值或单元格都具有时间戳，默认由系统指定，也可以由用户显示设置
  可以通过不同的时间戳来区分不同的版本的值，一个单元格的不同版本的值按照降序排列在一起，访问的时候优先读取最新的值。
  用户可以指定每个值所能保存的最大版本数，也就是最大保存多少个版本(系统默认保存3个版本)。hbase支持谓词删除，谓词删除：例子，允许用户 只保存过去一周内写入的值
  谓词：在计算机语言的环境下，谓词是指条件表达式的求值返回真或假的过程，比如大于、小于、等于等都是谓词
3.hbase中null值是省略的，空值是没有任何消耗的，它们不占用任何存储空间
4.hbase在抓取网页存储网页url时，url作为行健，一般将url反转后存储，比如：www.hbase.org,反转存储为org.hbase.www。原因是通过网址反转，把网址中最重要的部分————顶级域名放在最前面，可以让来自hbase.org的网页在HBASE中顺序地排列在一起。
5.由于hbase存储的文件是不可被改变的，所以无法通过移除某个键值对来简单地删除值。如果删除数据，解决方法：做个删除标记（墓碑标记），表明给定行已被删除的事实
6.为了避免部署中出现混乱，不推荐使用zoo.cfg文件进行hbase的配置，推荐只使用hbase-site.xml文件进行配置
  用户也可以在HBaseConfiguration类的create(Configuration conf)方法中，通过Configuration类的设置来进行HBase的配置。这里的配置比hbase-site.xml文件的优先级高，如果在Configuration中进行配置了，那么用Configuration中的配置，如果没有配置则用配置文件的配置。
  Configuration config = HbaseConfiguration.create();
  config.set(“hbase.zookeeper.quorum”,”zk1.foo.com,zk2.foo.com”);
7.配置节点个数，一般配置技术哥节点，因为偶数个节点不容易让服务器达成共识————Zookeeper集群需要一个绝大多数的投票，无论3台或者4台服务器都需要3个以上节点的投票，使用奇数的目的是只有在两台服务器都失败的情况下才不可用而使用偶数在一台服务器失败的情况下就会不可用。
8.用户应该尽量使用批量处理更新来减少单独操作同一行数据的次数————原因：当许多客户端需要同时修改同一行数据时会产生问题。
9.创建Hbase实例需要扫描.META表，以检查该表是否存在、是否可用，此外还要执行一些其他操作，这些检查和操作导致实例调用非常耗时。因此，推荐只创建一次HTable实例，而且是每个线程创建一个，然后在客户端应用的生存期内复用这个对象。
  如果用户需要使用多个HTable实例，应考虑使用HTablePool类，它为用户提供了一个复用多个实例的便捷方式。
10.region服务器采用了一种多版本并发控制机制（RWCC）这种机制保证了读程序读取数据时可以不用等待写程序完成写操作。写程序则需要等待其他写程序完成写操作之后才能继续执行。
11.Hbase在用put类的add方法保存数据的时候，add不指定时间戳时，Put实例会使用来自构造函数的可选时间戳参数，如果用户在构造Put实例时也没有指定时间戳，则时间戳将会由region服务器设定。
   建议使用region服务器的默认时间戳，而不是用户去指定。因为用户指定的时间戳与region服务器的时间不一定相同，这个时间差可能产生看似无序的版本历史。从而导致获取数据的时候，不一定是获取到最新的。
12.时间戳：每个时间戳是一个长整型值，以毫秒为单位。它表示自世界标准时间（UTC）1970年1月1日0时以来所经过的时间，这个时间又称Unix时间或Unix纪元。
   Java通过System.currentTimeMillis()函数来获取这个时间。
13.查询数据：scan和get操作只会返回最后的版本（最新数据），这是因为Hbase默认按照版本的降序存储，并且只返回一个版本。在调用中加入最大版本参数就可以获得多个版本的数据，如果将参数值设定为Integer.MAX_VALUE，就可以获得所有的版本。
   另外一个获取多版本数据的方法是：使用时间范围参数。只需要设置开始时间和结束时间，就能获得所有满足时间范围内的版本数据。
   对于某个特定单元格，有可能只有少于最大版本数个数版本，比如某个单元格只有2个版本，而我们设置的最大版本是3，这时该单元格只会显示2个版本。
14.行锁：Put类的构造函数有个名为rowlock的可选参数，它允许提交一个额外的 行锁。如果需要频繁重复修改某些行，用户有必要创建一个RowLock实例来防止其他客户端访问这些行。
15.基于类的比较比基于字节的比较效率低，因此最好使用基于字节的比较。
16.Put操作：每个put操作都是一个RPC操作，它将客户端数据传送到服务器然后返回。这只适合小数据量的操作，如果有个应用程序需要每秒存储上千行数据到HBase表中，这样处理就不好了。
   客户端发送一个请求到服务器，服务器进行回应，这个往返时间大约需要1毫秒（不包含数据传输的时间）。
   如果传输的数据量小，经常通信的话会影响性能，因此数据量较小的情况下，建议数据批量提交到服务器并减少请求次数，性能会有相应提升。(每次提交的数据量不易过大，因为这不仅会占用客户端内存，也会占用服务器端内存，而且万一断电，客户端缓存区的数据是无法恢复的)
   HBase提供了一个写缓冲区，它负责收集put操作，然后调用RPC操作一次性将Put送往服务器。默认情况下，这个缓冲区是禁用的。可通过将自动刷写设置为false来激活缓冲区。
   table.setAutoFlush(false);
   用户可以强制刷写缓冲区  flushCommits()，不过这通常不是必要的，因此API会追踪统计每个用户添加的实例的堆大小，从而计算出缓冲的数据量。除了追踪所有的数据开销，还会追踪必要的内部数据结构，一旦超出缓冲指定的大小限制，客户端就会隐式地调用刷写命令。
   用户配置客户端缓冲区的大小：setWriteBufferSize(long writeBufferSize),默认是2MB，这个比较适中，这个设置也可以在配置文件中进行配置。
   <property>
       <name>hbase.client.write.buffer</name>
       <value>20971520</value><!—-20MB—->
   </property>